#ifndef __INFO_HELPER_H__
#define __INFO_HELPER_H__


#include <iostream>
#include <fstream>
#include <streambuf>
#include <vector>
#include <string>
#include <memory.h>
#include <cstring>
#include <syncstream>
#include <iomanip>
#include <random>
#include <atomic>
//#include "attribute.h"
//#include "dataset.h"
#include "optimizers.h"
#include "matrix.h"
//#include "../util/csv_file.h"

namespace provallo
{
 
    //optimal spike decoding filter :
    //optimal linear kernel for spike train decoding 
    //see : https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2781884/
    //fisher information : 
    //https://en.wikipedia.org/wiki/Fisher_information
    //https://en.wikipedia.org/wiki/Linear_discriminant_analysis
    //https://en.wikipedia.org/wiki/Kernel_Fisher_discriminant_analysis

//joint distribution of spike train and stimulus
//p(s,x) = p(s|x) * p(x):
//p(s|x) = p(s,x) / p(x)
//p(x) = sum_s p(s,x)
//p(s|x) = p(s,x) / sum_s p(s,x)

    real_t joint_distribution(const std::vector<real_t> &spike_train, const std::vector<real_t> &stimulus)
    {
        real_t sum = 0.0;
        for (size_t i = 0; i < spike_train.size(); i++)
        {
            sum += spike_train[i] * stimulus[i];
        }
        return sum;
    }   
    real_t marginal_distribution(const std::vector<real_t> &spike_train)
    {
        real_t sum = 0.0;
        for (size_t i = 0; i < spike_train.size(); i++)
        {
            sum += spike_train[i];
        }
        return sum;
    }       
    real_t conditional_distribution(const std::vector<real_t> &spike_train, const std::vector<real_t> &stimulus)
    {
        return joint_distribution(spike_train, stimulus) / marginal_distribution(spike_train);
    }


    



    real_t fisher_information(const std::vector<real_t> &spike_train, real_t sigma= 1.0)
    {
        real_t sum = 0.0;
        for (size_t i = 0; i < spike_train.size(); i++)
        {
            sum += spike_train[i] * spike_train[i];
        }
        return sum / (sigma * sigma);
    }
    real_t linear_discriminant_analysis(const std::vector<real_t> &spike_train, real_t sigma = 1.0)
    {
        return fisher_information(spike_train, sigma);
    }       
    real_t kernel_fisher_discriminant_analysis(const std::vector<real_t> &spike_train, real_t sigma = 1.0)
    {
        return fisher_information(spike_train, sigma);
    }

    //recognition model :
    //https://en.wikipedia.org/wiki/Recognition_model
    //https://en.wikipedia.org/wiki/Recognition_model#Recognition_model_for_continuous_variables
    //https://en.wikipedia.org/wiki/Recognition_model#Recognition_model_for_discrete_variables


    
    //FACTORIAL CODING ,sparse coding dimensionality reduction:
    //https://en.wikipedia.org/wiki/Sparse_coding

    //https://en.wikipedia.org/wiki/Independent_component_analysis
    //https://en.wikipedia.org/wiki/Non-negative_matrix_factorization
    //https://en.wikipedia.org/wiki/Non-negative_matrix_factorization#Sparse_coding
    //https://en.wikipedia.org/wiki/Non-negative_matrix_factorization#Non-negative_sparse_coding

    //use gaussian mixture models for clustering : 
    //https://en.wikipedia.org/wiki/Mixture_model#Gaussian_mixture_model

    //https://en.wikipedia.org/wiki/Expectation%E2%80%93maximization_algorithm
    //https://en.wikipedia.org/wiki/Expectation%E2%80%93maximization_algorithm#Gaussian_mixture
    //https://en.wikipedia.org/wiki/Expectation%E2%80%93maximization_algorithm#Gaussian_mixture

    //Generative models: 
    //mixing proportions :
    //https://en.wikipedia.org/wiki/Mixture_model#Gaussian_mixture_model
    //https://en.wikipedia.org/wiki/Mixture_model#Gaussian_mixture_model



    //marginal distribution
    //p[u;G] = sum_k p[u,k;G] = sum_k p[u|k;G] * p[k;G]
    //p[u|k;G] = p[u,k;G] / p[k;G]
    //p[k;G] = sum_u p[u,k;G]
    //p[u|k;G] = p[u,k;G] / sum_u p[u,k;G]

    //joint distribution p[v,u;G] = p[v|u;G] * p[u;G]
    //p[v|u;G] = p[v,u;G] / p[u;G]
    //p[v,u;G] = p[v|u;G] * p[u;G]


    //recognition distribution (statistical inverse of the generative model):
    //the generative model can be used to generate samples from the distribution 
    //it is defined as P[v|u;G] = P[u|v;G] * P[v;G] / P[u;G]
    //and indicates how likely it is that a given sample v was generated by the generative model 
    //for instance P[v=A|u;G]=0.8 indicates that the sample v= neuron A was generated by the generative model with a probability of 0.8 
    //and P[v=B|u;G]=0.2 indicates that the sample v= neuron B was generated by the generative model with a probability of 0.2 

    
    template <typename T> 
    class gaussian_spike_train_generator
    {  
        private: 
        real_t _sigma; //standard deviation of the gaussian distribution
        real_t _mu; //mean of the gaussian distribution
        real_t _dt; //time step
        real_t _t; //current time
        real_t _t_max; //maximum time
        real_t _t_min; //minimum time
        real_t _t_step; //time step
        //mixing proportions :
        real_t _p; //probability of a spike
        real_t _q; //probability of no spike
        //generative model :
        //G = {p[u|k;G], p[k;G]} 
        std::vector<real_t> _G; //generative model
        
        //p[u;G] = sum_k p[u,k;G] = sum_k p[u|k;G] * p[k;G]
        //p[u|k;G] = p[u,k;G] / p[k;G]
        //random distribution :
        std::vector<real_t> _p_u_k_G; //p[u,k;G]
        std::vector<real_t> _p_u_G; //p[u;G]
        std::vector<real_t> _p_k_G; //p[k;G]
        //joint distribution :
        //p[v,u;G] = p[v|u;G] * p[u;G]
        //p[v|u;G] = p[v,u;G] / p[u;G]
        std::vector<real_t> _joint_distribution; //p[v,u;G]
        
        //recognition distribution :
        //P[v|u;G] = P[u|v;G] * P[v;G] / P[u;G]
        std::vector<real_t> _recognition_distribution; //P[v|u;G]

        //recognition model :
        //P[u|v;G] = P[v|u;G] * P[u;G] / P[v;G]
        std::vector<real_t> _recognition_model; //P[u|v;G]

        //random uniform distribution :
        std::vector<real_t> _p_u_k; //p[u,k]
        std::vector<real_t> _p_u; //p[u]
        std::vector<real_t> _p_k; //p[k]

        std::vector<real_t> _output; //output of the generator

        std::vector<real_t> _input; //aggregate input of the generator


        public:
        gaussian_spike_train_generator()
        : _sigma(1.0) , _mu(0.0) , _dt(1.0) ,_t(0.0) , _t_max(1.0),_t_min(0.0), _t_step(1.0), _p(0.5), _q(0.5), _G(2), _p_u_k_G(2), _p_u_G(2), _p_k_G(2), _joint_distribution(2), _recognition_distribution(2), _recognition_model(2), _p_u_k(2), _p_u(2), _p_k(2)
        {
            init();
        }
        gaussian_spike_train_generator(real_t sigma, real_t mu, real_t dt, real_t t_min, real_t t_max   )
        : _sigma(sigma) , _mu(mu) , _dt(dt) ,_t(t_min) , _t_max(t_max),_t_min(t_min), _t_step(t_min), _p(0.5), _q(0.5), _G(2), _p_u_k_G(2), _p_u_G(2), _p_k_G(2), _joint_distribution(2), _recognition_distribution(2), _recognition_model(2), _p_u_k(2), _p_u(2), _p_k(2)
        {
            init();
        }
        ~gaussian_spike_train_generator()
        {
        }
        void init(size_t in,size_t out)
        {
            _input.resize(in);
            _output.resize(out);
            //initialize the random distribution : 
            init();

        }
        void reset()
        {
            _t_step = _t_min;
            _t = _t_min;
        }
        void set_sigma(real_t sigma)
        {
            _sigma = sigma;
        }
        void set_mu(real_t mu)
        {
            _mu = mu;
        }
        void set_dt(real_t dt)
        {
            _dt = dt;
        }
        void set_t_min(real_t t_min)
        {
            _t_min = t_min;
        }
        void set_t_max(real_t t_max)
        {
            _t_max = t_max;
        }
        void set_t_step(real_t t_step)
        {
            _t_step = t_step;
        }
        real_t get_sigma() const
        {
            return _sigma;
        }
        real_t get_mu() const
        {
            return _mu;
        }
        real_t get_dt() const
        {
            return _dt;
        }
        real_t get_t_min() const
        {
            return _t_min;
        }
        real_t get_t_max() const
        {
            return _t_max;
        }
        real_t get_t_step() const
        {
            return _t_step;
        }
        real_t get_t() const
        {
            return _t;
        }
        void set_p(real_t p)
        {
            _p = p;
        }
        void set_q(real_t q)
        {
            _q = q;
        }
        real_t get_p() const
        {
            return _p;
        }
        real_t get_q() const
        {
            return _q;
        }
         
        void set_random_distribution(const std::vector<real_t> &p_u_k_G)
        {
            _p_u_k_G = p_u_k_G;
        }
        const std::vector<real_t> & get_random_distribution() const
        {
            return _p_u_k_G;
        }
        void set_joint_distribution(const std::vector<real_t> &joint_distribution)
        {
            _joint_distribution = joint_distribution;
        }
        const std::vector<real_t> & get_joint_distribution() const
        {
            return _joint_distribution;
        }
        void set_recognition_distribution(const std::vector<real_t> &recognition_distribution)
        {
            _recognition_distribution = recognition_distribution;
        }
        const std::vector<real_t> & get_recognition_distribution() const
        {
            return _recognition_distribution;
        }

        void set_recognition_model(const std::vector<real_t> &recognition_model)
        {
            _recognition_model = recognition_model;
        }
        const std::vector<real_t> & get_recognition_model() const
        {
            return _recognition_model;
        }

        void set_random_uniform_distribution(const std::vector<real_t> &p_u_k)
        {
            _p_u_k = p_u_k;
        }
        const std::vector<real_t> & get_random_uniform_distribution() const
        {
            return _p_u_k;
        }
        void set_p_u(const std::vector<real_t> &p_u)
        {
            _p_u = p_u;
        }
        const std::vector<real_t> & get_p_u() const
        {
            return _p_u;
        }
        void set_p_k(const std::vector<real_t> &p_k)
        {
            _p_k = p_k;
        }
        const std::vector<real_t> & get_p_k() const
        {
            return _p_k;
        }

        //set G
        void set_G(const std::vector<real_t> &G)
        {
            _G = G;
        }
        //get G
        const std::vector<real_t> & get_G() const
        {
            return _G;
        }
        //set input
        void set_input(const std::vector<real_t> &input)
        {
            _input = input;
        }
        //get input
        const std::vector<real_t> & get_input() const
        {
            return _input;
        }
        //set t
        void set_t(real_t t)
        {
            _t = t;
        }
        //get t
        real_t get_t()
        {
            return _t;
        }

        //initialize the generator :
        void init()
        {
            std::uniform_real_distribution<real_t> distribution(0.0, 1.0);
            std::uniform_int_distribution<int> distribution_int(0, 1);
            std::random_device rd;
            std::mt19937 gen(rd());
            //initialize the random distribution :
            //p[u,k;G] = p[u|k;G] * p[k;G]

            size_t n = (_t_max - _t_min) / _dt;
            _p_u_k_G.resize(n);
            _p_u_G.resize(n);
            _p_k_G.resize(n);
            _joint_distribution.resize(n);
            _recognition_distribution.resize(n);
            _recognition_model.resize(n);
            _p_u_k.resize(n);
            _p_u.resize(n);
            _p_k.resize(n);
            reset();
            //set random values for the generative model :
            for (size_t i = 0; i < n; i++)
            {
                _p_u_k_G[i] = distribution(gen);
                _p_u_G[i] = distribution(gen);
                _p_k_G[i] = distribution(gen);
                
                _p_u_k[i] = distribution(gen);
                _p_u[i] = distribution(gen);
                _p_k[i] = distribution(gen);
                _joint_distribution[i] = distribution(gen);
                _recognition_distribution[i] = distribution(gen);
                _recognition_model[i] = distribution(gen);

            }   

            //set default input 
            _input.resize(n);
            for (size_t i = 0; i < n; i++)
            {
                _input[i] = distribution(gen);
            }
            //set default output
            _output.resize(n);
            for (size_t i = 0; i < n; i++)
            {
                _output[i] = distribution(gen);
            }
            
            //set gaussian /mixed  distribution :
            //p[u,k;G] = p[u|k;G] * p[k;G]
            //p[u|k;G] = p[u,k;G] / p[k;G]
            //p[k;G] = sum_u p[u,k;G]
            //p[u|k;G] = p[u,k;G] / sum_u p[u,k;G]





            for (size_t i = 0; i < n; i++)
            {
                _p_k[i]= _p_u_k_G[i]/_p_u_k[i];
                _p_u[i]= _p_u_k_G[i]/_p_k[i];
                _p_u_k[i] = _p_u_k_G[i] / _p_k[i];
                _p_u_G[i]= _p_u_k_G[i]/_p_k_G[i];
                _p_u_k_G[i] = _p_u_k[i] * _p_k[i];
                _p_u_G[i]= _p_u_k_G[i]/_p_k_G[i];
                _p_k_G[i]= _p_u_k_G[i]/_p_u_G[i];
                _joint_distribution[i] = _p_u_k_G[i] * _p_u_G[i];
                _recognition_distribution[i] = _p_u_k_G[i] * _p_u_G[i];
                _recognition_model[i] = _p_u_k_G[i] * _p_u_G[i];

            }   
            //set default mixing proportions :
            _p = 0.5;
            _q = 1.0 - _p;
            //set default generative model :
            _G.resize(n);
            for (size_t i = 0; i < n; i++)
            {
                _G[i] = distribution(gen);
            }

        }
        real_t refine()
        {
            return refine(_input);
        }
        //refine the generator with EM algorithm :
        //gamma : mixing proportions 
        //https://en.wikipedia.org/wiki/Mixture_model#Gaussian_mixture_model
        real_t refine(const std::vector<real_t> input)
        {
            real_t result=0.0;
            this->_p = 0.5;
            this->_q = 1.0 - this->_p;
            if( this->_input!=input) {
                this->_input = input;
            }
            std::uniform_real_distribution<real_t> distribution(0.0, 1.0);
            std::uniform_int_distribution<int> distribution_int(0, 1);
            std::random_device rd;
            std::mt19937 gen(rd());
            std::gamma_distribution<real_t> gamma_distribution(1.0, 1.0); //gamma distribution with mean 1 and variance 1 : 
            std::normal_distribution<real_t> normal_distribution(0.0, 1.0); //gaussian distribution with mean 0 and variance 1 :

            //gaussian distribution with mean 0 and variance 1 : 
            provallo::Gaussian<real_t> gaussian(0.0, 1.0);
            gaussian.set_variance(1.0);
            gaussian.set_mean(0.0);
            gaussian.set_stddev(1.0);
            //initialize the random distribution :
            if( _G.size()==0)
            {
                _G.resize(input.size());
                for (size_t i = 0; i < input.size(); i++)
                {
                    _G[i] = distribution(gen);
                }
            }

            std::vector<real_t> results(input.size());
            matrix<real_t> gamma(input.size(), _G.size());
            matrix<real_t> SIGMA(input.size(), _G.size());
            matrix<real_t> gv(input.size(), _G.size());
            std::vector<real_t> generative(input.size());
            std::vector<real_t> recognition(input.size());
              //separate invertible and non-invertible matrices :
            matrix<real_t> invertible_gamma(input.size(), _G.size());
            matrix<real_t> invertible_SIGMA(input.size(), _G.size());
            matrix<real_t> invertible_gv(input.size(), _G.size());
            matrix<real_t> non_invertible_gamma(input.size(), _G.size());
            matrix<real_t> non_invertible_SIGMA(input.size(), _G.size());
            matrix<real_t> non_invertible_gv(input.size(), _G.size());
            matrix<real_t> gaussian_matrix(input.size(), _G.size());
            //initialize gamma <P([v|u;G])> :
            _p = 0.0;
            _q = 0.0;
            for (size_t i = 0; i < input.size(); i++)
            {
                for (size_t j = 0; j < _G.size(); j++)
                {
                    real_t gauss = gaussian();
                    //real_t g = gamma_distribution(gen);
                    if(gauss!=gauss)
                    {
                        //avoid -nan/nan
                        gauss=0.0;
                    }
                    //update gamma :
                    gamma(i,j) = _G[j] * input[i]   ;
                    SIGMA(i,j)  = input[i]/2.0*gamma(i,j);
                    gv(i,j) = gamma(i,j) * _p_u_k_G[i];
                    gaussian_matrix(i,j) =gauss;
                    //separate invertible and non-invertible matrices :
                    invertible_gamma(i,j) = gamma(i,j);
                    invertible_SIGMA(i,j)  = SIGMA(i,j);
                    invertible_gv(i,j) = gv(i,j);
                    non_invertible_gamma(i,j) = gamma(i,j);
                    non_invertible_SIGMA(i,j)  = SIGMA(i,j);
                    non_invertible_gv(i,j) = gv(i,j);
                    _p  +=   _p_u_k_G[i] * _p_u_G[i];
                    _q  +=   _p_u_k_G[i] * _p_u_G[i];
                    gaussian.set_mean(_G[j]);
                    gaussian.set_variance(SIGMA(i,j)); 
                                     
                }//end for j
                generative[i] = _G[i] * input[i] * _p_u_k_G[i] * _p_u_G[i];
                recognition[i] = _G[i] * input[i] * _p_u_k_G[i] * _p_u_G[i];
                result += generative[i];

                //debug _p and _q :
                std::cout<<"_p : "<<_p<<std::endl;
                std::cout<<"_q : "<<_q<<std::endl;
                std::cout<<"left:"<<std::to_string((input.size()-i)*_G.size())<<std::endl;            
                } //end for i
        
            _p= _p/input.size();
            _q= _q/input.size();
        
            //initialize joint distribution :
            this->_joint_distribution.resize(input.size());
            for (size_t i = 0; i < input.size(); i++)
            {
                this->_joint_distribution[i] = recognition[i] * generative[i];
            }
            //initialize recognition distribution :
            this->_recognition_distribution.resize(input.size());
            for (size_t i = 0; i < input.size(); i++)
            {
                this->_recognition_distribution[i] = recognition[i] * generative[i];
            }   
            //initialize recognition model :
            this->_recognition_model.resize(input.size());
            for (size_t i = 0; i < input.size(); i++)
            {
                this->_recognition_model[i] = recognition[i] * generative[i];
            }
            
            //use the gaussian matrix to compute the inverse of the matrices : 
 
            invertible_gamma.invert();
            invertible_SIGMA.invert();
            invertible_gv.invert();


            
            //prepare the EM algorithm :

            //E-step :
            //compute the expectation of the log-likelihood :
            //Q[v;u]    =  P[v|u;G] * P[u;G] * log(P[v|u;G] * P[u;G]) + P[v|u;G] * P[u;G] * log(P[v|u;G] * P[u;G]) 

            //M-step :
            
            //maximize the expectation of the log-likelihood :
            //use DKL to maximize the expectation of the log-likelihood :
            //DKL = sum_v P[v|u;G] * P[u;G] * log(P[v|u;G] * P[u;G] / P[v;G])
            //    = sum_v P[v|u;G] * P[u;G] * log(P[v|u;G] * P[u;G]) - sum_v P[v|u;G] * P[u;G] * log(P[v;G])
            //l(G)  =   <ln P[v|u;G]> - <ln P[v;G]>
            //      =   <ln P[v|u;G]> - <ln P[v;G]>


            //compute the expectation of the log-likelihood :
            //and maximize it :

            //Q[v;u]    =  P[v|u;G] * P[u;G] * log(P[v|u;G] * P[u;G]) + P[v|u;G] * P[u;G] * log(P[v|u;G] * P[u;G])
            //DKL = sum_v P[v|u;G] * P[u;G] * log(P[v|u;G] * P[u;G] / P[v;G])
            
            std::vector<real_t> Q(input.size(),0.0),DKL(input.size(),0.0),F(input.size(),0.0),W(input.size(),0.0); 
          
            matrix<real_t> g(input.size(), _G.size());
            for (size_t i = 0; i <g.size1();i++)
            {
                //g(i,j) = _G[j] * input[i] * _p_u_k_G[i] * _p_u_G[i];
                for ( size_t j = 0; j < g.size2(); j++  )
                {
                    g(i,j) = _G[j] * input[i] * _p_u_k_G[i] * _p_u_G[i];
                }   

                g(i,i) = _G[i] * input[i] * _p_u_k_G[i] * _p_u_G[i];
                
            }
            


            for (size_t i = 0; i < input.size(); i++)
            {
                Q[i] = recognition[i] * generative[i] * std::log(recognition[i] * generative[i]) + recognition[i] * generative[i] * std::log(recognition[i] * generative[i]);
                DKL[i] = Q[i] - ( recognition[i] * generative[i] * std::log(recognition[i] * generative[i] / recognition[i]) ); 
                W[i] = (Q[i] - DKL[i] ) / Q[i];
                F[i] = Q[i] - DKL[i] + W[i] * DKL[i] ;
            }
            //sum everything 
            for (size_t i = 0; i < input.size(); i++)
            {
                result += F[i]==F[i]?F[i]:0.0;
            }       
            //maximize the expectation of the log-likelihood :
            //use DKL to maximize the expectation of the log-likelihood :
            //DKL = sum_v P[v|u;G] * P[u;G] * log(P[v|u;G] * P[u;G] / P[v;G])

            //F(Q,G) = sum_v Q[v;u] ln  P[v|u;G] * P[u;G] - sum_v Q[v;u]    ln P[v|u;G] * P[u;G] / Q[v;u]   =
            //-1/2sigma|u - G * v|^2 + ln P[u;G] - ln P[u;G] / Q[v;u]


            
            //F(Q,G) = sum_v Q[v;u] ln  P[v|u;G] * P[u;G] - sum_v Q[v;u] ln P[v,u;G] / Q[v;u]   
            //F(Q,G) = sum_v Q[v;u] ln  P[v|u;G] * P[u;G] - sum_v Q[v;u] ln P[v|u;G] * P[u;G] / Q[v;u]


            //=L(G)-DKL(Q[v;u],P[v|u;G] * P[u;G])   
            //L(G) = sum_v Q[v;u] ln  P[v|u;G] * P[u;G] - sum_v Q[v;u] ln P[v|u;G] * P[u;G] / Q[v;u] + DKL(Q[v;u],P[v|u;G] * P[u;G])
            //maximize and set _output to the results  :

            //maximize the expectation of the log-likelihood :
            _output.resize(input.size());
            //use DKL to maximize the expectation of the log-likelihood :
           //DKL = sum_v P[v|u;G] * P[u;G] * log(P[v|u;G] * P[u;G] / P[v;G])

            for ( size_t i=0 ; i < input.size(); i++ )
            {
                _output[i] = F[i]==F[i]?F[i] : 0.;
            }  
            std::cout<<"[+] infohelper debug gaussian refine returning: "
            <<std::to_string(result/real_t(input.size()))<< std::endl; 
            return result / real_t(input.size()); 

        }
        //get output:
        const std::vector<real_t> & get_output() const
        {
            return _output;
        }
        void reset_steps()
        {
            _t_step = _t_min;
            _t = _t_min;
        }

        //generate a spike train :
        std::vector<real_t> generate()
        {
            std::vector<real_t> result;
            std::uniform_real_distribution<real_t> distribution(0.0, 1.0);
            std::uniform_int_distribution<int> distribution_int(0, 1);
            std::random_device rd;
            std::mt19937 gen(rd());
            reset_steps();
            //generate a spike train :
            while (_t_step < _t_max)
            {
                _t_step += _dt;
                _t += _dt;
                if (distribution(gen) < _p)
                {
                    result.push_back(1.0);
                }
                else
                {
                    result.push_back(0.0);
                }

            }
            return result;
        }       
        //generate a spike train :
        std::vector<real_t> operator()()
        {
            return generate();
        }   

        //generate a spike train :
        std::vector<real_t> operator()(real_t sigma, real_t mu, real_t dt, real_t t_min, real_t t_max)
        {
            set_sigma(sigma);
            set_mu(mu);
            set_dt(dt);
            set_t_min(t_min);
            set_t_max(t_max);
            return generate();
        }
        //generate a spike train with input :
        std::vector<real_t> operator()(const std::vector<real_t> &input)
        {
            return refine(input);
        }   
        //generate a spike train with input :
        std::vector<real_t> operator()(const std::vector<real_t> &input, real_t sigma, real_t mu, real_t dt, real_t t_min, real_t t_max)
        {
            set_sigma(sigma);
            set_mu(mu);
            set_dt(dt);
            set_t_min(t_min);
            set_t_max(t_max);
            return refine(input);
        }
        //generate a spike train with input :
        std::vector<real_t> operator()(const std::vector<real_t> &input, real_t sigma, real_t mu, real_t dt, real_t t_min, real_t t_max, const std::vector<real_t> &G)
        {
            set_sigma(sigma);
            set_mu(mu);
            set_dt(dt);
            set_t_min(t_min);
            set_t_max(t_max);
            _G = G;
            return refine(input);
        }
        //gnuplot output :
        void gnuplot(const std::string& file)
        {
            //create .dat file for multiple plots : 
            std::ofstream out(file + ".dat");
            out << "#t input  " << "\t" << "output" << std::endl;
            for (size_t i = 0; i < _output.size(); i++)
            {
                out << i << "\t" <<  _input[i] <<"\t"<< _output[i] << std::endl;

            }


            out.close();


        }

        //sum of output :
        real_t sum ( )const 
        {
            real_t result=0.0;
            for(size_t i=0;i<_output.size();i++)
            {
                result += _output[i];
            }
            return result;
        }

        //mean of output :
        real_t mean ( )const 
        {
            real_t result=0.0;
            for(size_t i=0;i<_output.size();i++)
            {
                result += _output[i];
            }
            return result/_output.size();
        }   
        //variance of output :
        real_t variance ( )const 
        {
            real_t result=0.0;
            real_t mean = this->mean();
            for(size_t i=0;i<_output.size();i++)
            {
                result += (_output[i]-mean)*(_output[i]-mean);
            }
            return result/_output.size();
        }
        //standard deviation of output :
        real_t standard_deviation ( )const 
        {
            return sqrt(variance());
        }
        //skewness of output :
        real_t skewness ( )const 
        {
            real_t result=0.0;
            real_t mean = this->mean();
            real_t standard_deviation = this->standard_deviation();
            for(size_t i=0;i<_output.size();i++)
            {
                result += (_output[i]-mean)*(_output[i]-mean)*(_output[i]-mean);
            }
            return result/(_output.size()*standard_deviation*standard_deviation*standard_deviation);
        }   
        //kurtosis of output :
        real_t kurtosis ( )const 
        {
            real_t result=0.0;
            real_t mean = this->mean();
            real_t standard_deviation = this->standard_deviation();
            for(size_t i=0;i<_output.size();i++)
            {
                result += (_output[i]-mean)*(_output[i]-mean)*(_output[i]-mean)*(_output[i]-mean);
            }
            return result/(_output.size()*standard_deviation*standard_deviation*standard_deviation*standard_deviation);
        }       
        //entropy of output :
        real_t entropy ( )const 
        {
            real_t result=0.0;
            for(size_t i=0;i<_output.size();i++)
            {
                result += _output[i]*std::log(_output[i]);
            }
            return result;
        }
        //cross entropy of output :
        real_t cross_entropy ( )const 
        {
            real_t result=0.0;
            for(size_t i=0;i<_output.size();i++)
            {
                result += _output[i]*std::log(_output[i]);
            }
            return result;
        }   
        //KL divergence of output :
        real_t KL_divergence ( )const 
        {
            real_t result=0.0;
            for(size_t i=0;i<_output.size();i++)
            {
                result += _output[i]*std::log(_output[i]/_output[i]);
            }
            return result;
        }                           


    };
    //implementation of helmholtz machine :
    //https://en.wikipedia.org/wiki/Helmholtz_machine
    //https://en.wikipedia.org/wiki/Expectation%E2%80%93maximization_algorithm
    //https://en.wikipedia.org/wiki/Generative_model
    //https://en.wikipedia.org/wiki/Recognition_model
    //https://en.wikipedia.org/wiki/Statistical_classification

    template <typename T>
    class helmholtz_machine
    {   
        private: 

        size_t _n;//number of layers
        size_t _m;//number of neurons
        size_t _k;//number of spikes
        size_t _l;//number of spikes
        size_t _t;//time
        size_t _t_step;//time step
        
        std::vector<real_t> _input;
        std::vector<real_t> _output;
        std::vector<real_t> _generative_model;
        std::vector<real_t> _recognition_model;
        std::vector<real_t> _recognition_distribution;
        std::vector<real_t> _random_distribution;
        std::vector<real_t> _joint_distribution;
        std::vector<real_t> _random_uniform_distribution;
        std::vector<real_t> _F_phase;
        std::vector<real_t> _W_phase;
        std::vector<real_t> _Q_phase;
        std::vector<real_t> _DKL_phase;
        gaussian_spike_train_generator<T> _generator;
        real_t _alpha = 0.99;//learning rate 
        public:
        helmholtz_machine(size_t n=1, size_t m=1, size_t k=1, size_t l=1, size_t t=0, size_t t_step=0):_n(n),_m(m),_k(k),_l(l),_t(t),_t_step(t_step),_generator(1.0,0.0,0.1,0.0,1.0)
        {
            init();
        }   

        ~helmholtz_machine()
        {
        } 
        void init(size_t in, size_t out) 
        {
            _generator.init(in,out);
            _input.resize(in);
            _output.resize(out);
            _generative_model.resize(out);
            _recognition_model.resize(in);
            _recognition_distribution.resize(in);
            _random_distribution.resize(in);
            _joint_distribution.resize(in);
            _random_uniform_distribution.resize(in);
            _F_phase.resize(in);
            _W_phase.resize(in);
            _Q_phase.resize(in);
            _DKL_phase.resize(in);
            _alpha = 0.99;
            reset();
        }  
        void reset()
        {
            _generator.reset();
        }
        void set_sigma(real_t sigma)
        {
            _generator.set_sigma(sigma);
        }
        void set_mu(real_t mu)
        {
            _generator.set_mu(mu);
        }
        void set_dt(real_t dt)
        {
            _generator.set_dt(dt);
        }
        void set_t_min(real_t t_min)
        {
            _generator.set_t_min(t_min);
        }
        void set_t_max(real_t t_max)
        {
            _generator.set_t_max(t_max);
        }
        void set_t_step(real_t t_step)
        {
            _generator.set_t_step(t_step);
        }
        real_t get_sigma() const
        {
            return _generator.get_sigma();
        }
        real_t get_mu() const
        {
            return _generator.get_mu();
        }
        real_t get_dt() const
        {
            return _generator.get_dt();
        }
        real_t get_t_min() const
        {
            return _generator.get_t_min();
        }
        real_t get_t_max() const
        {
            return _generator.get_t_max();
        }
        real_t get_t_step() const
        {
            return _generator.get_t_step();
        }
        real_t get_t() const
        {
            return _generator.get_t();
        }
        void set_p(real_t p)
        {
            _generator.set_p(p);
        }
        void set_q(real_t q)
        {
            _generator.set_q(q);
        }
        real_t get_p() const
        {
            return _generator.get_p();
        }
        real_t get_q() const
        {
            return _generator.get_q();
        }
        void set_generative_model(const std::vector<real_t> &G)
        {
            _generator.set_generative_model(G);
        }   
        const std::vector<real_t> & get_generative_model() const
        {
            return _generator.get_generative_model();
        }
        void set_random_distribution(const std::vector<real_t> &p_u_k_G)
        {
            _generator.set_random_distribution(p_u_k_G);
        }
        const std::vector<real_t> & get_random_distribution() const
        {
            return _generator.get_random_distribution();
        }
        void set_joint_distribution(const std::vector<real_t> &joint_distribution)
        {
            _generator.set_joint_distribution(joint_distribution);
        }
        const std::vector<real_t> & get_joint_distribution() const
        {
            return _generator.get_joint_distribution();
        }
        void set_recognition_distribution(const std::vector<real_t> &recognition_distribution)
        {
            _generator.set_recognition_distribution(recognition_distribution);
        }
        const std::vector<real_t> & get_recognition_distribution() const
        {
            return _generator.get_recognition_distribution();
        }

        void set_recognition_model(const std::vector<real_t> &recognition_model)
        {
            _generator.set_recognition_model(recognition_model);
        }
        //generate: 
        std::vector<real_t> generate()
        {
            //generate a spike train :
            std::vector<real_t> result;
            std::uniform_real_distribution<real_t> distribution(0.0, 1.0); 
            std::uniform_int_distribution<int> distribution_int(0, 1);
            std::random_device rd;
            std::mt19937 gen(rd());
            while (_generator.get_t_step() < _generator.get_t_max())
            {
                _generator.set_t_step(_generator.get_t_step() + _generator.get_dt());
                _generator.set_t(_generator.get_t() + _generator.get_dt());
                if (distribution(gen) < _generator.get_p())
                {
                    result.push_back(1.0);
                }
                else
                {
                    result.push_back(0.0);
                }
            }   
            return result;
        }
        void refine()
        {
            refine(_input);
        }
        real_t refine(const std::vector<real_t> input)
        {
            real_t res = 0.0;
            _generator.set_input(input);
            res = _generator.refine();
            _output = _generator.get_output();
            return res;
        }

        //refine the generator with EM algorithm :
        //gamma : mixing proportions
        //https://en.wikipedia.org/wiki/Mixture_model#Gaussian_mixture_model
         void init()
        {
            _generator.init();
            //initialize the random distribution :
            //p[u,k;G] = p[u|k;G] * p[k;G]
            Gaussian<real_t> gaussian(0.0, 1.0);
            size_t n = (_generator.get_t_max() - _generator.get_t_min()) / _generator.get_dt();
            _random_distribution.resize(n);
            _generative_model.resize(n);
            _recognition_model.resize(n);
            _joint_distribution.resize(n);
            _recognition_distribution.resize(n);
            _random_uniform_distribution.resize(n);
            //set random values for the generative model :
            for (size_t i = 0; i < n; i++)
            {
                            //set gaussian /mixed  distribution :
                            //p[u,k;G] = p[u|k;G] * p[k;G]
                            //p[u|k;G] = p[u,k;G] / p[k;G]
                            //p[k;G] = sum_u p[u,k;G]
                            //p[u|k;G] = p[u,k;G] / sum_u p[u,k;G]


                _random_distribution[i] =gaussian();
                _generative_model[i] = gaussian();
                _recognition_model[i] = gaussian();
                _joint_distribution[i] = gaussian();
                _recognition_distribution[i] = gaussian();
                _random_uniform_distribution[i] = gaussian();
                gaussian.set_mean(_generator.get_G()[i]);
                gaussian.set_variance(_generator.get_sigma());

            }   
            //set gaussian /mixed  distribution :
            //p[u,k;G] = p[u|k;G] * p[k;G]
            //p[u|k;G] = p[u,k;G] / p[k;G]
            //p[k;G] = sum_u p[u,k;G]

            for (size_t i = 0; i < n; i++)
            {
                _generative_model[i] = _generative_model[i] * _random_distribution[i];
                _recognition_model[i] = _recognition_model[i] * _random_distribution[i];
                _joint_distribution[i] = _joint_distribution[i] * _random_distribution[i];
                _recognition_distribution[i] = _recognition_distribution[i] * _random_distribution[i];
                _random_uniform_distribution[i] = _random_uniform_distribution[i] * _random_distribution[i];
            }
            //set default mixing proportions :
            _generator.set_p(0.5);
            _generator.set_q(1.0 - _generator.get_p());
            //set default generative model :
            _generator.set_G(_generative_model);
            //initialize the recognition model :
            _generator.set_recognition_model(_recognition_model);
            //initialize the recognition distribution :
            _generator.set_recognition_distribution(_recognition_distribution);
            //initialize the random distribution :
            _generator.set_random_distribution(_random_distribution);
            //initialize the joint distribution :
            _generator.set_joint_distribution(_joint_distribution);
            //initialize the random uniform distribution :
            _generator.set_random_uniform_distribution(_random_uniform_distribution);
            //initialize the F phase :
            this->_F_phase=_random_uniform_distribution;
            //initialize the W phase :
            this->_W_phase=_random_uniform_distribution;
            //initialize the Q phase :
            this->_Q_phase=_random_uniform_distribution;
            //initialize the DKL phase :
            this->_DKL_phase=_random_uniform_distribution;
            
            
            //set default input
            _input.resize(n);
            for (size_t i = 0; i < n; i++)
            {
                _input[i] = gaussian();
            }
            //set default output
            _output.resize(n);
            for (size_t i = 0; i < n; i++)
            {
                _output[i] = gaussian();
            }
            
        }
        void set_random_uniform_distribution(const std::vector<real_t> &p_u_k)
        {
            _generator.set_random_uniform_distribution(p_u_k);
        }
        const std::vector<real_t> & get_random_uniform_distribution() const
        {
            return _generator.get_random_uniform_distribution();
        }
        void set_p_u(const std::vector<real_t> &p_u)
        {
            _generator.set_p_u(p_u);
        }
        const std::vector<real_t> & get_p_u() const
        {
            return _generator.get_p_u();
        }
        void set_p_k(const std::vector<real_t> &p_k)
        {
            _generator.set_p_k(p_k);
        }
        const std::vector<real_t> & get_p_k() const
        {
            return _generator.get_p_k();
        }
        void set_input(const std::vector<real_t> &input)
        {
            _input = input;
        }
        const std::vector<real_t> & get_input() const
        {
            return _input;
        }
        void set_output(const std::vector<real_t> &output)
        {
            _output = output;
        }
        
        const std::vector<real_t> & get_output() const
        {
            return _output;
        }
       
        std::vector<real_t> & get_output() 
        {
            return _output;
        }
         
 
        void set_F_phase(const std::vector<real_t> &F_phase)
        {
            _F_phase = F_phase;
        }
        const std::vector<real_t> & get_F_phase() const
        {
            return _F_phase;
        }
        void set_W_phase(const std::vector<real_t> &W_phase)
        {
            _W_phase = W_phase;
        }
        const std::vector<real_t> & get_W_phase() const
        {
            return _W_phase;
        }
        void set_Q_phase(const std::vector<real_t> &Q_phase)
        {
            _Q_phase = Q_phase;
        }
        const std::vector<real_t> & get_Q_phase() const
        {
            return _Q_phase;
        }
        void set_DKL_phase(const std::vector<real_t> &DKL_phase)
        {
            _DKL_phase = DKL_phase;
        }

        const std::vector<real_t> & get_DKL_phase() const
        {
            return _DKL_phase;
        }
        void set_n(size_t n)
        {
            _n = n;
        }
        size_t get_n() const
        {
            return _n;
        }
        void set_m(size_t m)
        {
            _m = m;
        }
        size_t get_m() const
        {
            return _m;
        }
        void set_k(size_t k)
        {
            _k = k;
        }
        size_t get_k() const
        {
            return _k;
        }
        void set_l(size_t l)
        {
            _l = l;
        }
        size_t get_l() const
        {
            return _l;
        }
        void set_t(size_t t)
        {
            _t = t;
        }
        
        void set_t_step(size_t t_step)
        {
            _t_step = t_step;
        }
        //learning rules : 
        //wake sleep algorithm :
        //https://en.wikipedia.org/wiki/Wake-sleep_algorithm
        //https://en.wikipedia.org/wiki/Expectation%E2%80%93maximization_algorithm

        //wake : u ~P[u],v~Q[v;u,W] 
        //       g-> g+eta(v-f(g))
        //       h-> h+eta(u-f(h+Gv))
        //       G-> G+eta(u-f(h+Gv))v
        //sleep : v ~P[v;G],u~P[u|v;G]
        //        w-> w+eta(v-f(w+W dot u))
        //        W-> W+eta(v-f(w+W dot u))u
        //        
        
        void update_sleep()
        {
            //apply the sleep phase :

            reset();
            //generate a spike train :
            _input = _generator();
            //refine the generator :
            _output = _generator(_input);
            //update the recognition model :
            _recognition_model = _generator.get_recognition_model();
            //update the recognition distribution :
            _recognition_distribution = _generator.get_recognition_distribution();
            //update the random distribution :
            _random_distribution = _generator.get_random_distribution();
            //update the joint distribution :
            _joint_distribution = _generator.get_joint_distribution();
            //update the random uniform distribution :
            _random_uniform_distribution = _generator.get_random_uniform_distribution();
            //update the F phase :
            _F_phase = _generator.get_F_phase();

            //update the W phase :
            _W_phase = _generator.get_W_phase();

            //update the Q phase :
            _Q_phase = _generator.get_Q_phase();

            //update the DKL phase :
            _DKL_phase = _generator.get_DKL_phase();

            //update the generative model :
            _generative_model = _generator.get_generative_model();

            //apply the sleep phase :
            //u ~P[u],v~Q[v;u,W]
            //g-> g+eta(v-f(g))
            //h-> h+eta(u-f(h+Gv))
            //G-> G+eta(u-f(h+Gv))v

            //update the generative model :
            _generative_model = _generator.get_generative_model();
            //update the random distribution :
            _random_distribution = _generator.get_random_distribution();
            //update the joint distribution :
            _joint_distribution = _generator.get_joint_distribution();
            //update the recognition distribution :
            _recognition_distribution = _generator.get_recognition_distribution();
        }
        void update_wake()
        {
            //apply the wake phase :
            reset();
            //generate a spike train :
            
            _input = _generator();
            //refine the generator :
            _output = _generator(_input);
            //update the recognition model :
            _recognition_model = _generator.get_recognition_model();
            //update the recognition distribution :
            _recognition_distribution = _generator.get_recognition_distribution();
            //update the random distribution :
            _random_distribution = _generator.get_random_distribution();
            //update the joint distribution :
            _joint_distribution = _generator.get_joint_distribution();
            //update the random uniform distribution :
            _random_uniform_distribution = _generator.get_random_uniform_distribution();
            //update the F phase :
            _F_phase = _generator.get_F_phase();

            //update the W phase :
            _W_phase = _generator.get_W_phase();

            //update the Q phase :
            _Q_phase = _generator.get_Q_phase();

            //update the DKL phase :
            _DKL_phase = _generator.get_DKL_phase();


            //update the generative model :
            _generative_model = _generator.get_generative_model();

            //apply the wake phase :
            //v ~P[v;G],u~P[u|v;G]
            //w-> w+eta(v-f(w+W dot(u)
            //W-> W+eta(v-f(w+W dot(u))u

            //update the generative model :
            for (size_t i = 0; i < _generative_model.size(); i++)
            {
                _generative_model[i] = _generative_model[i] + _generator.get_eta() * (_output[i] - _generative_model[i]);
            } 
            //update the random distribution : 
            for (size_t i = 0; i < _random_distribution.size(); i++)
            {
                _random_distribution[i] = _random_distribution[i] + _generator.get_eta() * (_output[i] - _random_distribution[i]);
            }
            //update the joint distribution :
            for (size_t i = 0; i < _joint_distribution.size(); i++)
            {
                _joint_distribution[i] = _joint_distribution[i] + _generator.get_eta() * (_output[i] - _joint_distribution[i]);
            }
            //update the recognition distribution :
            for (size_t i = 0; i < _recognition_distribution.size(); i++)
            {
                _recognition_distribution[i] = _recognition_distribution[i] + _generator.get_eta() * (_output[i] - _recognition_distribution[i]);
            }
            //update the recognition model :
            for (size_t i = 0; i < _recognition_model.size(); i++)
            {
                _recognition_model[i] = _recognition_model[i] + _generator.get_eta() * (_output[i] - _recognition_model[i]);
            } 
            //update the random uniform distribution : 
            for (size_t i = 0; i < _random_uniform_distribution.size(); i++)
            {
                _random_uniform_distribution[i] = _random_uniform_distribution[i] + _generator.get_eta() * (_output[i] - _random_uniform_distribution[i]);
            } 
            //update the F phase :
            for (size_t i = 0; i < _F_phase.size(); i++)
            {
                _F_phase[i] = _F_phase[i] + _generator.get_eta() * (_output[i] - _F_phase[i]);
            } 
            //update the W phase :
            for (size_t i = 0; i < _W_phase.size(); i++)
            {
                _W_phase[i] = _W_phase[i] + _generator.get_eta() * (_output[i] - _W_phase[i]);
            }
            //update the Q phase :
            for (size_t i = 0; i < _Q_phase.size(); i++)
            {
                _Q_phase[i] = _Q_phase[i] + _generator.get_eta() * (_output[i] - _Q_phase[i]);
            }
            //update the DKL phase :
            for (size_t i = 0; i < _DKL_phase.size(); i++)
            {
                _DKL_phase[i] = _DKL_phase[i] + _generator.get_eta() * (_output[i] - _DKL_phase[i]);
            } 
            //update the generative model :
            for (size_t i = 0; i < _generative_model.size(); i++)
            {
                _generative_model[i] = _generative_model[i] + _generator.get_eta() * (_output[i] - _generative_model[i]);
            }
            //update the random distribution again :
            for (size_t i = 0; i < _random_distribution.size(); i++)
            {
                _random_distribution[i] = _random_distribution[i] + _generator.get_eta() * (_output[i] - _random_distribution[i]);
            }
            //update the joint distribution again : 
            for (size_t i = 0; i < _joint_distribution.size(); i++)
            {
                _joint_distribution[i] = _joint_distribution[i] + _generator.get_eta() * (_output[i] - _joint_distribution[i]);
            } 
            //update the output:
            
            //done :


        }   

        //refine the generator with EM algorithm :
        //gamma : mixing proportions
        //https://en.wikipedia.org/wiki/Mixture_model#Gaussian_mixture_model
        


    };
    //implementation of boltzmann machine :
    //https://en.wikipedia.org/wiki/Boltzmann_machine
    //https://en.wikipedia.org/wiki/Expectation%E2%80%93maximization_algorithm
    //https://en.wikipedia.org/wiki/Generative_model
    //https://en.wikipedia.org/wiki/Recognition_model



    template <typename T>
    class boltzman_base
    {
        private:
        size_t _n;//number of layers
        size_t _m;//number of neurons
        size_t _k;//number of spikes
        size_t _l;//number of spikes
        size_t _t;//time
        size_t _t_step;//time step
        T _sigma;
        T _mu;
        T _dt;
        T _t_min;
        T _t_max;
        T _p;
        T _q;

        std::vector<T> _input;
        std::vector<T> _output;
        std::vector<real_t> _generative_model;

        std::vector<real_t> _recognition_model;
        std::vector<real_t> _recognition_distribution;
        std::vector<real_t> _random_distribution;
        std::vector<real_t> _joint_distribution;
        std::vector<real_t> _random_uniform_distribution;
        std::vector<real_t> _F_phase;
        std::vector<real_t> _W_phase;
        std::vector<real_t> _Q_phase;
        std::vector<real_t> _DKL_phase;
        //generator :
        gaussian_spike_train_generator<T> _generator;
        public:
        
        boltzman_base( size_t n=1, size_t m=1, size_t k=1, size_t l=1, size_t t=1, size_t t_step=1):_n(n),_m(m),_k(k),_l(l),_t(t),_t_step(t_step),_sigma(1.0),_mu(0.0),_dt(0.1),_t_min(0.0),_t_max(1.0),_p(0.5),_q(1.0-_p),_generator(1.0,0.0,0.1,0.0,1.0)
        {
            init();
        } 
        void init(size_t in ,size_t out)
        {
            _generator.init(in,out);
            _input.resize(in);
            _output.resize(out);
            _generative_model.resize(out);
            _recognition_model.resize(in);
            _recognition_distribution.resize(in);
            _random_distribution.resize(in);
            _joint_distribution.resize(in);
            _random_uniform_distribution.resize(in);
            _F_phase.resize(in);
            _W_phase.resize(in);
            _Q_phase.resize(in);
            _DKL_phase.resize(in);
            reset();

        }
        void init() 
        {
            //initialize the random distribution :
            //p[u,k;G] = p[u|k;G] * p[k;G]
            Gaussian<real_t> gaussian(0.0, 1.0);
            _random_distribution.resize(_n);
            _generative_model.resize(_n);
            _recognition_model.resize(_n);
            _joint_distribution.resize(_n);
            _recognition_distribution.resize(_n);
            _random_uniform_distribution.resize(_n);
             //set default input
            _input.resize(_n);
            for (size_t i = 0; i < _n; i++)
            {
                _input[i] = gaussian();
            }
            //set default output
            _output.resize(_n);
            for (size_t i = 0; i < _n; i++)
            {
                _output[i] = gaussian();
            }
            //set default F phase :
            _F_phase.resize(_n);
            for (size_t i = 0; i < _n; i++)
            {
                _F_phase[i] = gaussian();
            }
            //set default W phase :
            _W_phase.resize(_n);
            for (size_t i = 0; i < _n; i++)
            {
                _W_phase[i] = gaussian();
            }
            //set default Q phase :
            _Q_phase.resize(_n);
            for (size_t i = 0; i < _n; i++)
            {
                _Q_phase[i] = gaussian();
            }
            //set default DKL phase :
            _DKL_phase.resize(_n);
            for (size_t i = 0; i < _n; i++)
            {
                _DKL_phase[i] = gaussian();
            }
            //set default generative model :
            _generative_model.resize(_n);
            //set random values for the generative model :
            for (size_t i = 0; i < _n; i++)
            {
                _random_distribution[i] =gaussian();
                _generative_model[i] = gaussian();
                _recognition_model[i] = gaussian();
                _joint_distribution[i] = gaussian();
                _recognition_distribution[i] = gaussian();
                _random_uniform_distribution[i] = gaussian();
                gaussian.set_mean(_generative_model[i]);
                gaussian.set_variance(_sigma);

            }   
            //set gaussian /mixed  distribution :
            //p[u,k;G] = p[u|k;G] * p[k;G]
            //p[u|k;G] = p[u,k;G] / p[k;G]
            //p[k;G] = sum_u p[u,k;G]
            //p[u|k;G] = p[u,k;G] / sum_u p[u,k;G] 
            for (size_t i = 0; i < _n; i++)
            {
                _generative_model[i] = _generative_model[i] * _random_distribution[i];
                _recognition_model[i] = _recognition_model[i] * _random_distribution[i];
                _joint_distribution[i] = _joint_distribution[i] * _random_distribution[i];
                _recognition_distribution[i] = _recognition_distribution[i] * _random_distribution[i];
                _random_uniform_distribution[i] = _random_uniform_distribution[i] * _random_distribution[i];
            }
            //set default mixing proportions :
            _p = 0.5;
            _q = 1.0 - _p;
            //set default generative model :
            _generator.set_G(_generative_model);
            //initialize the recognition model :
            _generator.set_recognition_model(_recognition_model);
            //initialize the recognition distribution :
            _generator.set_recognition_distribution(_recognition_distribution);
            //initialize the random distribution :
            _generator.set_random_distribution(_random_distribution);
            //initialize the joint distribution :
            _generator.set_joint_distribution(_joint_distribution);
            //initialize the random uniform distribution :
            _generator.set_random_uniform_distribution(_random_uniform_distribution);
            //initialize the F phase :
            this->_F_phase = _random_uniform_distribution; 
            //initialize the W phase :
            this->_W_phase = _random_uniform_distribution;
            //initialize the Q phase :
            this->_Q_phase = _random_uniform_distribution;
            //initialize the DKL phase :
            this->_DKL_phase = _random_uniform_distribution;
            

            //initialize the output :
            _output.resize(_n);
            for (size_t i = 0; i < _n; i++)
            {
                _output[i] = gaussian();
            }
            
           

        }
        std::vector<real_t> generate()
        {
            //generate a spike train :
            std::vector<real_t> result;
            std::uniform_real_distribution<real_t> distribution(0.0, 1.0); 
            std::uniform_int_distribution<int> distribution_int(0, 1);
            std::random_device rd;
            std::mt19937 gen(rd());
            while (_t_step < _t_max)
            {
                _t_step += _dt;
                _t += _dt;
                if (distribution(gen) < _p)
                {
                    result.push_back(1.0);
                }
                else
                {
                    result.push_back(0.0);
                }
            }   
            return result;
        }   
        void refine()
        {
            refine(_input);
        }
        real_t refine(const std::vector<real_t> input)
        {
            real_t res = 0.0;
            _generator.set_input(input);

            res = _generator.refine();
            _output = _generator.get_output();

            maximize();

            return res;
        }
        ~boltzman_base()
        {
        }
        void reset()
        {
            _generator.reset();

            if(_n>0){
            //reset the generator :
            //reset the input :
            _input.resize(_n,0.0);
            //reset the output :
            _output.resize(_n,0.0);
            //reset the generative model :
            _generative_model.resize(_n,0.0);
            //reset the recognition model :
            _recognition_model.resize(_n,0.0);
            //reset the recognition distribution :
            _recognition_distribution.resize(_n,0.0);
            //reset the random distribution :
            _random_distribution.resize(_n,0.0);
            //reset the joint distribution :
            _joint_distribution.resize(_n,0.0);
            //reset the random uniform distribution :
            _random_uniform_distribution.resize(_n,0.0);
            //reset the F phase :
            _F_phase.resize(_n,0.0);

            //reset the W phase :
            _W_phase.resize(_n,0.0);
            }
        }
        void set_sigma(real_t sigma)
        {
            _sigma = sigma;
        }
    //Lyapunov  L(I) = <lnQ[v]-lnP[v]>_Q + Nvk  -lnZ
    //free energy F(I) = -L(I)
    //KL divergence DKL(I) = -L(I) - H(I)
    //entropy H(I) = -<lnQ[v]>_Q - Nvk + lnZ
    //Z = sum_v P[v] = sum_v exp(-L(I))

        void set_mu(real_t mu)
        {
            _mu = mu;
        }
        void set_dt(real_t dt)
        {
            _dt = dt;
        }
        void set_t_min(real_t t_min)
        {
            _t_min = t_min;
        }
        void set_t_max(real_t t_max)
        {
            _t_max = t_max;
        }
        void set_t_step(real_t t_step)
        {
            _t_step = t_step;
        }
        real_t get_sigma() const
        {
            return _sigma;
        }
        real_t get_mu() const
        {
            return _mu;
        }
        real_t get_dt() const
        {
            return _dt;
        }
        real_t get_t_min() const
        {
            return _t_min;
        }
        real_t get_t_max() const
        {
            return _t_max;
        }
        real_t get_t_step() const
        {
            return _t_step;
        }
        real_t get_t() const
        {
            return _t;
        }
        void set_p(real_t p)
        {
            _p = p;
        }
        void set_q(real_t q)
        {
            _q = q;
        }
        real_t get_p() const
        {
            return _p;
        }
        real_t get_q() const
        {
            return _q;
        }

        void set_generative_model(const std::vector<real_t> &G)
        {
            _generative_model = G;
        }
        const std::vector<real_t> & get_generative_model() const
        {
            return _generative_model;
        }
        void set_random_distribution(const std::vector<real_t> &p_u_k_G)
        {
            _random_distribution = p_u_k_G;
        }
        const std::vector<real_t> & get_random_distribution() const
        {
            return _random_distribution;
        }

        void set_joint_distribution(const std::vector<real_t> &joint_distribution)
        {
            _joint_distribution = joint_distribution;
        }
        const std::vector<real_t> & get_joint_distribution() const
        {
            return _joint_distribution;
        }
        void set_recognition_distribution(const std::vector<real_t> &recognition_distribution)
        {
            _recognition_distribution = recognition_distribution;
        }
        const std::vector<real_t> & get_recognition_distribution() const
        {
            return _recognition_distribution;
        }

        //calculate the lyaounov :
        real_t lyapunov()
        {
             //L(I) = <lnQ[v]-lnP[v]>_Q + Nvk  -lnZ
            real_t result = 0.0;
            for (size_t i = 0; i < _output.size(); i++)
            {
                result += _output[i]*std::log(_output[i]) - _output[i] * std::log(_output[i]);
            }
            result = result / _output.size();
            return -result;
        }
        //calculate the free energy :
        real_t free_energy()
        {
            return -lyapunov();
        }
        //calculate the KL divergence :
        real_t KL_divergence()
        {
            return -lyapunov() - entropy();
        }
        //calculate the entropy :
        real_t entropy()
        {
            real_t result = 0.0;
            //Z = sum_v P[v] = sum_v exp(-L(I))
            real_t Z = 0.0;
            for (size_t i = 0; i < _output.size(); i++)
            {
                Z += std::exp(-lyapunov());
            }
            return -result - _output.size() * _dt + std::log(Z);
        }
        //calculate the cross entropy :
        real_t cross_entropy()
        {
            real_t result = 0.0;
            //Z = sum_v P[v] = sum_v exp(-L(I))
            real_t Z = 0.0;
            for (size_t i = 0; i < _output.size(); i++)
            {
                for(size_t i=0;i<_input.size();i++)
                {
                    result += _output[i]*std::log(_input[i]);
                }
                Z += std::exp(-lyapunov());
            }
            //
            result = result / _output.size();

            return -result - _output.size() * _dt + std::log(Z);
        }   
        //calculate the mean :
        real_t mean()
        {
            real_t result = 0.0;
            for (size_t i = 0; i < _output.size(); i++)
            {
                result += _output[i];
            }
            return result / _output.size();
        }   
        //calculate the variance :
        real_t variance()
        {
            real_t result = 0.0;
            real_t mean = this->mean();
            for (size_t i = 0; i < _output.size(); i++)
            {
                result += (_output[i] - mean) * (_output[i] - mean);
            }
            return result / _output.size();
        }
        //calculate the standard deviation :
        real_t standard_deviation()
        {
            return std::sqrt(variance());
        }
        //calculate the skewness :
        real_t skewness()
        {
            real_t result = 0.0;
            real_t mean = this->mean();
            real_t standard_deviation = this->standard_deviation();
            for (size_t i = 0; i < _output.size(); i++)
            {
                result += (_output[i] - mean) * (_output[i] - mean) * (_output[i] - mean);
            }
            return result / (_output.size() * standard_deviation * standard_deviation * standard_deviation);
        }
        //calculate the kurtosis :
        real_t kurtosis()
        {
            real_t result = 0.0;
            real_t mean = this->mean();
            real_t standard_deviation = this->standard_deviation();
            for (size_t i = 0; i < _output.size(); i++)
            {
                result += (_output[i] - mean) * (_output[i] - mean) * (_output[i] - mean) * (_output[i] - mean);
            }
            return result / (_output.size() * standard_deviation * standard_deviation * standard_deviation * standard_deviation);
        }

        // maximize the expectation of the log-likelihood :
        // use DKL to maximize the expectation of the log-likelihood :
        // DKL(Q[v;u],P[v|u;G] * P[u;G]) = sum_v Q[v;u] ln  P[v|u;G] * P[u;G] - sum_v Q[v;u] ln P[v;G]
        // 
        real_t  maximize()
        {
            //maximize the expectation of the log-likelihood :
            //use DKL to maximize the expectation of the log-likelihood :
            //DKL(Q[v;u],P[v|u;G] * P[u;G]) = sum_v Q[v;u] ln  P[v|u;G] * P[u;G] - sum_v Q[v;u] ln P[v;G]
            //maximize and set _output to the results  :
            real_t result = 0.0;
            
            size_t n = std::min(_DKL_phase.size(), _output.size());
            for (size_t i = 0; i < n; i++)
            {
                result += _DKL_phase[i];
                _output[i] = _DKL_phase[i];
            }
            return result;
            
        }
        //minimize the expectation of the log-likelihood :
        //use DKL to minimize the expectation of the log-likelihood :
        //DKL(Q[v;u],P[v|u;G] * P[u;G]) = sum_v Q[v;u] ln  P[v|u;G] * P[u;G] - sum_v Q[v;u] ln P[v;G]
        real_t minimize()
        {
            real_t result=0.;
            //update the phases :
            //update the F phase :
            _F_phase = _generator.get_F_phase();
            //update the W phase :
            _W_phase = _generator.get_W_phase();
            //update the Q phase :
            _Q_phase = _generator.get_Q_phase();
            //update the DKL phase :
            _DKL_phase = _generator.get_DKL_phase();
            //minimize the expectation of the log-likelihood :
            //use DKL to minimize the expectation of the log-likelihood :
            //DKL(Q[v;u],P[v|u;G] * P[u;G]) = sum_v Q[v;u] ln  P[v|u;G] * P[u;G] - sum_v Q[v;u] ln P[v;G]
            //minimize and set _output to the results  :
            size_t n = std::min(_DKL_phase.size(), _output.size());
            for (size_t i = 0; i < n; i++)
            {
                result += _DKL_phase[i];
                _output[i] = _DKL_phase[i];
            }
             return result;
        }
        //get output :
        const std::vector<real_t> & get_output() const
        {
            return _output;
        }   
        std::vector<real_t> & get_output() 
        {
            return _output;
        }
        //set output :
        void set_output(const std::vector<real_t> &output)
        {
            _output = output;
        }
        //get input :
        const std::vector<real_t> & get_input() const
        {
            return _input;
        }
        //set input :

        void set_input(const std::vector<real_t> &input)
        {
            _input = input;
        }

 
    };


}



#endif // __INFO_HELPER_H__ 